{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/core/services/subjects/subjects.service\";\nexport class Row {}\nexport let ImportService = /*#__PURE__*/(() => {\n  class ImportService {\n    constructor(subjectsService) {\n      this.subjectsService = subjectsService;\n      this.limit = 100;\n      this.removedChars = ['\"', '='];\n      this.importing = new BehaviorSubject(false);\n    }\n\n    formatSubjects(rows, patient, donors) {\n      let donGenotypes = [];\n      let patGenotypes = [];\n      let donIDs = [];\n      let patIDs = [];\n      rows.forEach(function (row) {\n        donGenotypes.push(row['donHlaB1'] + '+' + row['donHlaB2']);\n        donIDs.push(row['donID']);\n\n        if (row['patHlaB1']) {\n          patGenotypes.push(row['patHlaB1'] + '+' + row['patHlaB2']);\n          patIDs.push(row['patID']);\n        }\n      });\n      this.subjectsService.addGenotypes(patGenotypes, patient);\n      this.subjectsService.addGenotypes(donGenotypes, donors);\n      this.subjectsService.addIDs(patIDs, patient);\n      this.subjectsService.addIDs(donIDs, donors);\n    }\n\n    parseRows(lines) {\n      let headers = lines.shift().map(a => a.trim());\n      headers = this._numberDuplicates(headers);\n      this.hlaHeaders = [];\n      this.idHeaders = [];\n      let line; // Header indices\n\n      let hlaB_indices = [];\n      let id_indices = [];\n\n      for (let j = 0; j < headers.length; j++) {\n        if (headers[j].match(/^B \\d$/)) {\n          hlaB_indices.push(j);\n        } else if (headers[j].match(/GRID/g)) {\n          id_indices.push(j);\n        }\n      }\n\n      if (!hlaB_indices.length) {\n        line = lines[0];\n\n        for (let i = 0; i < line.length; i++) {\n          if (line[i].match(/B\\*/g)) {\n            hlaB_indices.push(i);\n          } else {\n            id_indices.push(i);\n          }\n        }\n\n        id_indices.reverse();\n        hlaB_indices.reverse();\n      }\n\n      const service = this;\n      let rows = [];\n      let çç;\n\n      for (let i = 1; i <= lines.length; i++) {\n        let row = new Row();\n        line = lines[i - 1];\n\n        for (let j = 0; j < hlaB_indices.length; j++) {\n          let value = this._removeChars(line[hlaB_indices[j]]);\n\n          if (value) {\n            if (j >= 2) {\n              row['patHlaB' + (j - 2 + 1)] = value.includes('B*') ? value : 'B*' + value;\n            } else {\n              row['donHlaB' + (j + 1)] = value.includes('B*') ? value : 'B*' + value;\n            }\n          }\n        }\n\n        for (let k = 0; k < 2; k++) {\n          let prefix = k ? 'pat' : 'don';\n          let idIndex = id_indices.length >= 2 ? id_indices[k] : id_indices[0]; // if (!idIndex){\n          //   idIndex = id_indices[k;]\n          // }\n\n          console.log(prefix, idIndex, id_indices, k, line);\n          row[prefix + 'ID'] = this._removeChars(line[idIndex]);\n        }\n\n        rows.push(row);\n      } // let rows = rawSubjects.map(function(rawSubject : Object) {\n      //   let row = new Row();\n      //   row['donHlaB1'] = rawSubject[service.hlaHeaders[1]];\n      //   row['donHlaB2'] = rawSubject[service.hlaHeaders[0]];\n      //   if (service.hlaHeaders.length == 4) {\n      //     row['patHlaB1'] = rawSubject[service.hlaHeaders[3]];\n      //     row['patHlaB2'] = rawSubject[service.hlaHeaders[2]];\n      //   } else {\n      //     // TODO: Process incorrect # of hla columns\n      //   }\n      //   for (let i = 0; i < service.hlaHeaders.length / 2; i++){\n      //     let prefix = i ? 'pat' : 'don';\n      //     let idHeaders = service.idHeaders.length == 2 ? service.idHeaders[i] : service.idHeaders[0];\n      //     row[prefix + 'ID'] = rawSubject[idHeaders];\n      //   }\n      //   return row;\n      // })\n\n\n      return rows;\n    } // _determineHeaders(lines: Array<Array<string>>) {\n    //   let headers = lines.shift().map(a => a.trim());\n    //   headers = this._numberDuplicates(headers);\n    //   console.log(headers);\n    //   this.hlaHeaders = [];\n    //   this.idHeaders = [];\n    //   for (const [key, value] of Object.entries(subject)) {\n    //     if (key.match(/^B$/g) || key.match(/B\\*/g)){\n    //       this.hlaHeaders.push(key);\n    //     } else {\n    //       this.idHeaders.push(key);\n    //     }\n    //   }\n    //   console.log(this.hlaHeaders);\n    //   console.log(this.idHeaders);\n    //   this.hlaHeaders.reverse();\n    //   this.idHeaders.reverse();\n    // }\n\n\n    _numberDuplicates(headers) {\n      let map = {};\n      const count = headers.map(function (val) {\n        return map[val] = typeof map[val] === \"undefined\" ? 1 : map[val] + 1;\n      });\n      const numberedHeaders = headers.map(function (val, index) {\n        return val + (map[val] != 1 ? ' ' + count[index] : '');\n      });\n      return numberedHeaders;\n    }\n\n    _removeChars(value) {\n      while (value && this.removedChars.some(c => value.indexOf(c) > 0)) {\n        this.removedChars.forEach(c => {\n          value = value.replace(c, '');\n        });\n      }\n\n      return value ? value.replace(/(\\r\\n|\\n|\\r)/gm, \"\") : value;\n    }\n\n    setAsImporting(importing) {\n      this.importing.next(importing);\n    }\n\n    getLimit() {\n      return this.limit;\n    }\n\n  }\n\n  ImportService.ɵfac = function ImportService_Factory(t) {\n    return new (t || ImportService)(i0.ɵɵinject(i1.SubjectsService));\n  };\n\n  ImportService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ImportService,\n    factory: ImportService.ɵfac,\n    providedIn: 'root'\n  });\n  return ImportService;\n})();","map":null,"metadata":{},"sourceType":"module"}